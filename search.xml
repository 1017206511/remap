<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA-HashMap</title>
    <url>/yzq-blog/2021/04/07/uzq9ht/</url>
    <content><![CDATA[<h1 id="JDK-版本-1-8"><a href="#JDK-版本-1-8" class="headerlink" title="JDK 版本 1.8"></a>JDK 版本 1.8</h1><h1 id="HashMap-是什么"><a href="#HashMap-是什么" class="headerlink" title="HashMap 是什么"></a>HashMap 是什么</h1><p>hashMap 是一个 key-value 结构的集合。可以存储对象在集合中，进行查找，按照 hash 分组等操作。</p>
<h1 id="HashMap-类长什么样"><a href="#HashMap-类长什么样" class="headerlink" title="HashMap 类长什么样"></a>HashMap 类长什么样</h1><p><img src="https://cdn.nlark.com/yuque/0/2021/png/8415306/1617863711643-ea89cbdd-bb73-44eb-9ddf-1d925886f6a9.png#height=276&id=hVrBs&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1192&originalType=binary&size=33397&status=done&style=none&width=596" alt="image.png"></p>
<h2 id="最顶层接口-Map"><a href="#最顶层接口-Map" class="headerlink" title="最顶层接口 Map"></a>最顶层接口 Map</h2><p>定义了所有 Map 类型集合的通用属性。包括 key 和 value 的泛型。常见方法有</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取当前map的长度。指当前map存储了多少对key-value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否为空map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断key是否在map中存在</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断value是否存在</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据key获取map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 插入一对键值对</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据key删除某一个键值对</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将另一个map全部插入到当前map中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 清空map</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取key的set</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取所有的value</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将所有的键值对转换成Map.Entry集合返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 按照key获取value或者返回defaultValue</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">       V v;</span><br><span class="line">       <span class="keyword">return</span> (((v = get(key)) != <span class="keyword">null</span>) || containsKey(key))</span><br><span class="line">           ? v</span><br><span class="line">           : defaultValue;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>发现了一个新的类型：Map.Entry</strong><br><strong>​</strong></p>
<p>这是一个接口，在 Map 接口中定义的关联 key-value 的对象。下面所有的 map 子类如果需要维护 Entry 都需要实现此接口</p>
<h2 id="HashMap-的直接父类-AbstractMap"><a href="#HashMap-的直接父类-AbstractMap" class="headerlink" title="HashMap 的直接父类 AbstractMap"></a>HashMap 的直接父类 AbstractMap</h2><p>继承 Map 接口。对于 Map 接口的一些方法做了默认的实现。主要实现的默认方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过entrySet()获取所有的键值对，循环遍历判断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过entrySet()获取所有的键值对，循环遍历判断</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过entrySet()获取所有的键值对，循环遍历获取</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据key移除键值对。通过entrySet()遍历匹配。然后通过迭代器remove</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将参数map的entrySet()循环put</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>hashMap 对 AbstractMap 类中的方法进行了一些重写。主要对于 get、put 等逻辑的调整。在 JDK1.8 中 HashMap 引入了红黑树，所以由原来的 entrySet 循环遍历变成了根据树来遍历，减小极端情况的耗时</p>
<h1 id="HashMap-是怎样存储这些数据的"><a href="#HashMap-是怎样存储这些数据的" class="headerlink" title="HashMap 是怎样存储这些数据的"></a>HashMap 是怎样存储这些数据的</h1><p>hashMap 的底层存储结构为链表加数组。可以参考下图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8415306/1617867925505-eb135913-1179-4e86-a3c8-ac0561ee73bb.png#height=426&id=OsYZX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=852&originWidth=1314&originalType=binary&size=93565&status=done&style=none&width=657" alt="image.png"><br><strong>注意：</strong><br>HashMap 在存储数据时并不会保证数据插入的顺序性。比如说按照顺序插入&lt;a,1&gt;,&lt;b,1&gt;&lt;c,1&gt;<br>可能读取出来的是{a:1, c:1, b:1}。这与 hashMap 的插入逻辑有关</p>
<h1 id="hashMap-从初始化开始到插入数据的工作流程"><a href="#hashMap-从初始化开始到插入数据的工作流程" class="headerlink" title="hashMap 从初始化开始到插入数据的工作流程"></a>hashMap 从初始化开始到插入数据的工作流程</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//步骤1</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">9</span>);</span><br><span class="line">        <span class="comment">//步骤2</span></span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//步骤3</span></span><br><span class="line">        map.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-初始化"><a href="#HashMap-初始化" class="headerlink" title="HashMap 初始化"></a>HashMap 初始化</h2><p>查看本次 hashMap 的构造方法<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8415306/1618284732854-e23bdd64-6d99-4f8f-86f4-c021ce314823.png#height=232&id=WRiGe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=1338&originalType=binary&size=69594&status=done&style=none&width=669" alt="image.png"><br>发现重载调用了另一个构造，分别传了两个数据，一个是 <strong>列表初始化大小</strong>，一个是 <strong>载荷系数（默认 0.75）。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/8415306/1618284808464-380092d6-72d3-4ec0-93e9-de4e1cf79d67.png#height=282&id=SBnAy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=564&originWidth=1412&originalType=binary&size=95106&status=done&style=none&width=706" alt="image.png"><br>下面的构造方法进行了一些基础判断。包括初始容量是否小于 0 是否大于默认最大值（1 &lt;&lt; 30 为 1073741824），载荷系数不能为 null 和小于等于 0<br>**注意：列表长度并不是直接赋值，是转换了一层。**tableSizeFor 方法做了一个事情。就是将传入的数据进行转换。换成一个等于或者大于传入值得最近的二得幂等次方数。如 9 -&gt; 16, 17 -&gt; 32<br><strong>载荷系数：</strong><br><strong>这个值决定了 map 的长度在达到多少时进行扩容。如 map 设置长度为 8,载荷系数为 0.75。那么 map 长度在 6 时就会进行扩容操作</strong><br><strong>列表初始化大小：</strong><br><strong>这个值决定了 hashMap key 的链表长度，但是不能限制 hashMap 的实际节点长度</strong></p>
<h2 id="HashMap-插入元素-核心"><a href="#HashMap-插入元素-核心" class="headerlink" title="HashMap 插入元素(核心)"></a>HashMap 插入元素(核心)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//定义变量tab 所有节点的列表 节点p 根据hash算出的下标对应的节点</span></span><br><span class="line">    	<span class="comment">//n 节点列表长度 i hash对应的列表下标</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    	<span class="comment">//给tab进行赋值，并判断是否为null 给列表长度赋值并判断列表长度是否为0</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    	<span class="comment">//根据key的hash值进行与运算，获取hash在链表中的节点，节点不存在时就直接创建</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//判断节点上的hash、key、都一一致</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//将节点赋值给e变量</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//key等不一致时，发生了hash碰撞。不同hash映射到一个列表下标了。判断节点是否是树节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//进行红黑树的对比，插入</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//创建一个循环，一直循环到自动break终止</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//将p节点(当前节点 第一次循环时是map的数组元素节点)下一个节点赋值给e，并判断p节点是否还有下一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//不存在时将新的k v 生成节点并插入</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//判断是否达到转换成红黑树的条件。 默认是一个下标上的数组长度大于等于7，进行判断转换</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            <span class="comment">//数组转红黑树方法,但是此方法不一定会转换成红黑树，方法内部有判断：</span></span><br><span class="line">                            <span class="comment">//整个map长度为空或者map长度小于64.进行map长度初始化/扩容</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//判断节点e是否和插入的k、v一致，一致则跳出循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//将节点e赋值给p 继续递归</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//e节点不为null时,判断是否更新旧节点或者旧节点为null，是则更新旧节点</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//修改次数加一</span></span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//map长度加一，并判断是否大于下一次扩容的阈值了</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//map长度扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap-扩容或者数组初始化操作"><a href="#HashMap-扩容或者数组初始化操作" class="headerlink" title="HashMap 扩容或者数组初始化操作"></a>HashMap 扩容或者数组初始化操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    	<span class="comment">//旧的map长度</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    	<span class="comment">//下一次扩容阈值</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果旧的map长度大于了最大容量(2的30次方默认1073741824),则直接扩容成int的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//旧长度扩容一倍, 且小于最大值 大于默认值16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//扩容阈值也同步增加一倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环旧数组，并放入新数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//数组元素为叶子节点 或者为末尾的节点，直接重新计算下标，插入新数组</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//已经树化的节点，需要进行高低位重新排序插入的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//非树化的节点，依然是进行高低位重排序，只是在重新插入新数组 是否转换树的区别</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//区分树链表的高低位(其实就是元素插入新数组时下标是否改变, 等于0即为不改变，是低位树链表，反之则为改变)</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//低位尾部标记为null,表示还未开始处理，此时e是第一个要处理的低位树链表</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//节点，故e.prev等于loTail都等于null</span></span><br><span class="line">                        loHead = e;<span class="comment">//低位树链表的第一个树链表节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    <span class="comment">//低位树链表元素个数计数</span></span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//高位树链表的第一个树链表节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    <span class="comment">//高位树链表元素个数计数</span></span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;<span class="comment">//低位树链表不为null</span></span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<span class="comment">//低位树链表元素个数若小于等于6</span></span><br><span class="line">                    tab[index] = loHead.untreeify(map);<span class="comment">//开始去树化操作(就是将元素TreeNode节点都转换成Node节点)</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified) //若高位数链表头节点为空，说明还没有处理完高位</span></span><br><span class="line">                    <span class="comment">//，还不能进行树化操作</span></span><br><span class="line">                        loHead.treeify(tab);<span class="comment">//低位树链表元素个数若大于6且高位树链表头节点不等于null，开始将低位树链表真</span></span><br><span class="line">                        <span class="comment">//正树化成红黑树(前面都只是挂着TreeNode的名号，但实际只是链表结构，还没包含红黑树的特性，</span></span><br><span class="line">                        <span class="comment">//在这里才赋予了它红黑树的特性)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;<span class="comment">//高位树链表不为null</span></span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<span class="comment">//高位树链表元素个数若小于等于6</span></span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);<span class="comment">//开始去树化操作(就是将元素TreeNode节点都转换成Node节点)</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) <span class="comment">//若低位数链表头节点为空，说明还没有处理完低位，还不能进行树化操作</span></span><br><span class="line">                        hiHead.treeify(tab);<span class="comment">//高位树链表元素个数若大于6且低位树链表头节点不等于null，</span></span><br><span class="line">                        <span class="comment">//开始将高位树链表真正树化成红黑树</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解析：​<br>1，split()方法中的四个参数 分别是：当前 hashMap 对象、新数组、正在遍历的旧数组下标、旧数组的长度。<br>他主要分为两个操作：</p>
<ul>
<li>数据从旧数组转移到新数组中时，旧数组上的数据会根据(e.hash &amp; bit)是否等于 0 (<a href="#LyjKj">注 1</a>)，重新 rehash 计算其在数组上的索引位置，分两种情况：<ul>
<li>等于 0 时，则将该树链表头节点放到新数组时的索引位置等于其在旧数组时的索引位置，记为低位区树链表 lo。</li>
<li>不等于 0 时，则将该树链表头节点放到新数组时的索引位置等于其在旧数组时的索引位置再加上旧数组长度，记为高位区树链表 hi</li>
</ul>
</li>
<li>当红黑树被 split 分割开成为两个小红黑树后：<ul>
<li>当低位区小红黑树元素个数小于等于 6 时，开始去树化 untreeify 操作；</li>
<li>当低位区小红黑树元素个数大于 6 且高位区红黑树不为 null 时，开始树化操作(赋予红黑树的特性)。</li>
</ul>
</li>
</ul>
<p>​</p>
<p>2，循环树状节点的操作时：<br>e 初始为当前节点，计算 e 的 hash 和旧的数组长度与计算是否为 0（无需改动下标。）是，则将当前节点塞入低位树头部，并将节点的下一个节点设置给 e，然后继续递归判断。<br>​</p>
<p>3，例子：处理一个 3–&gt;5–&gt;7 的链表，过程如下：</p>
<ol>
<li>首先处理节点 3，e==3，e.next==5</li>
<li>一开始 loTail 是 null，所以把 3 赋值给 loHead。</li>
<li>把 3 赋值给 loTail</li>
<li>处理节点 5，e==5，e.next==7</li>
<li>loTail 有值，把 e 赋值给 loTail.next，也就是 3.next==5。</li>
<li>把 5 赋值给 loTail。</li>
</ol>
<p>只要 loTail 不是 null，说明链表中的元素在新 table 中的下标没变，所以新 table 的对应下标中放的是 loHead，另外把 loTail 的 next 设为 null​<br>反之，hiTail 不是 null，说明链表中的元素在新 table 中的下标，应该是原下标加原 table 长度，新 table 对应下标处放的是 hiHead，另外把 hiTail 的 next 设为 null</p>
<h2 id="HashMap-删除元素"><a href="#HashMap-删除元素" class="headerlink" title="HashMap 删除元素"></a>HashMap 删除元素</h2><p>remove 操作<br>remove 操作的所有前置步骤都和插入操作一样，都是根据 key 的 hash 来查找到 node 节点，然后删除。链表的切换下一个节点指向 a -》 b -》 c 变为 a -》 c。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h4 id="注-1"><a href="#注-1" class="headerlink" title="注 1"></a>注 1</h4><p>正常情况下，计算节点在 table 中的下标的方法是：hash&amp;(oldTable.length-1)，扩容之后，table 长度翻倍，计算 table 下标的方法是 hash&amp;(newTable.length-1)，也就是 hash&amp;(oldTable.length*2-1)，于是我们有了这样的结论：这新旧两次计算下标的结果，要不然就相同，要不然就是新下标等于旧下标加上旧数组的长度。<br>假设 table 原长度是 16，扩容后长度 32，那么一个 hash 值在扩容前后的 table 下标是这么计算的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/8415306/1620976750177-12802b58-26c6-4e1b-8064-caf80f85b804.png#clientId=u97db8012-2744-4&from=paste&height=285&id=ud3a5ea93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=498&originalType=binary&size=21460&status=done&style=none&taskId=u6c57d696-d846-45ca-a8a9-bea555e44a9&width=498" alt="image.png"><br>hash 值的每个二进制位用 abcde 来表示，那么，hash 和新旧 table 按位与的结果，最后 4 位显然是相同的，唯一可能出现的区别就在第 5 位，也就是 hash 值的 b 所在的那一位，如果 b 所在的那一位是 0，那么新 table 按位与的结果和旧 table 的结果就相同，反之如果 b 所在的那一位是 1，则新 table 按位与的结果就比旧 table 的结果多了 10000（二进制），而这个二进制 10000 就是旧 table 的长度 16。​<br>换言之，hash 值的新散列下标是不是需要加上旧 table 长度，只需要看看 hash 值第 5 位是不是 1 就行了，位运算的方法就是 hash 值和 10000（也就是旧 table 长度）来按位与，其结果只可能是 10000 或者 00000。所以，e.hash &amp; oldCap，就是用于计算位置 b 到底是 0 还是 1 用的，只要其结果是 0，则新散列下标就等于原散列下标，否则新散列坐标要在原散列坐标的基础上加上原 table 长度。<br>​</p>
<blockquote>
<p>参考博客：<a href="https://blog.csdn.net/lkforce/article/details/89521318">https://blog.csdn.net/lkforce/article/details/89521318</a></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
        <tag>map</tag>
      </tags>
  </entry>
</search>
